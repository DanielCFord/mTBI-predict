function cfgScreen = visual_stim_properties(cfgScreen, cfgExp, windowRect)
% cfgScreen = visual_stim_properties(cfgScreen, cfgExp, windowRect)
% define the destination rectangle in which visStims will be presented
% width and height should be in visual degrees
% windowRect -> output of PsychImaging('OpenWindow',...), is the fullsize of the screen

[xCentre, yCentre] = RectCenter(windowRect);  % get centre coordinates 
cfgScreen.centre = [xCentre, yCentre];

cfgScreen.destVisStimCentreBig = [0, 0, angle2pix(cfgScreen, cfgScreen.destRectBigW), angle2pix(cfgScreen, cfgScreen.destRectBigH)];
cfgScreen.destVisStimCentreBig = CenterRect(cfgScreen.destVisStimCentreBig, windowRect);  % for big central stimulus
cfgScreen.destVisStimCentreSmall = [0, 0, angle2pix(cfgScreen, cfgScreen.destRectSmallW), angle2pix(cfgScreen, cfgScreen.destRectSmallH)];
cfgScreen.destVisStimCentreSmall = CenterRect(cfgScreen.destVisStimCentreSmall, windowRect);  % for small central stimulus

% move stimuli 3 degrees to right/left and 2 degress below the fixation dot
% (centre point) + use pixel size of central stimulus (in destRectH and W)
cfgScreen.destVisStimBigR = cfgScreen.destVisStimCentreBig + angle2pix(cfgScreen, cfgScreen.visStimToR);  
cfgScreen.destVisStimBigL = cfgScreen.destVisStimCentreBig - angle2pix(cfgScreen, cfgScreen.visStimToL);  
cfgScreen.destVisStimSmallR = cfgScreen.destVisStimCentreSmall + angle2pix(cfgScreen, cfgScreen.visStimToR);  
cfgScreen.destVisStimSmallL = cfgScreen.destVisStimCentreSmall - angle2pix(cfgScreen, cfgScreen.visStimToL);  
cfgScreen.destVisStimMedR = (cfgScreen.destVisStimBigR + cfgScreen.destVisStimSmallR)./2;
cfgScreen.destVisStimMedL = (cfgScreen.destVisStimBigL + cfgScreen.destVisStimSmallL)./2;
visStimRectMatR = [cfgScreen.destVisStimBigR; cfgScreen.destVisStimMedR; cfgScreen.destVisStimSmallR]';
visStimRectMatL = [cfgScreen.destVisStimBigL; cfgScreen.destVisStimMedL; cfgScreen.destVisStimSmallL]';

% Make the destination rectangle 0.5 degree smaller according to
% stimSpeedFrm
for stm = 1:length(cfgExp.stimFrm)
    cfgScreen.destVisStimR{stm} = repmat(visStimRectMatR, 1, ceil(cfgExp.stimFrm(stm)/size(visStimRectMatR, 2)));
    cfgScreen.destVisStimL{stm} = repmat(visStimRectMatL, 1, ceil(cfgExp.stimFrm(stm)/size(visStimRectMatL, 2)));  
end

visStimAngMatR = 0:cfgExp.stimSpeedFrm:360;
visStimAngMatL = 360:-cfgExp.stimSpeedFrm:0;

% rotation angle of visual stimulus
for stm = 1:length(cfgExp.stimFrm(stm))
    cfgScreen.stimAngleR{stm} = repmat(visStimAngMatR,1,ceil(cfgExp.stimFrm(stm)/length(visStimAngMatR)));  % every cfgExp.stimSpeedFrm = one complete rotation
    cfgScreen.stimAngleL{stm} = repmat(360:-(cfgExp.stimSpeedFrm-5):0,1,ceil(cfgExp.stimFrm(stm)/cfgExp.stimSpeedFrm));  
end
 
% calculate the centre of visual stimuli (for dot flash presentation)
cfgScreen.rectLR = [CenterRect(cfgScreen.fixDotRect, cfgScreen.destVisStimL)...
    ; CenterRect(cfgScreen.fixDotRect, cfgScreen.destVisStimR)];  % put both rects in one matrix for use in another function

% destination of cue
rectCue = [0, 0, angle2pix(cfgScreen, cfgScreen.destRectCueSize), angle2pix(cfgScreen, cfgScreen.destRectCueSize)];
cfgScreen.destCue = CenterRect(rectCue, windowRect) + angle2pix(cfgScreen, cfgScreen.cueToB);  % move cue stim to bottom

end

